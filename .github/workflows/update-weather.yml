name: Update Weather Data (Safe, validated cache updates)
permissions:
  contents: write

on:
  schedule:
    - cron: "0 7,14 * * *"   # 10:00 and 17:00 Greece time
  workflow_dispatch:

jobs:
  update-weather:
    name: Run updater (matrix batch)
    runs-on: ubuntu-latest
    strategy:
      matrix:
        batch: [0,1,2,3,4,5,6,7,8,9]
      fail-fast: false

    steps:
      - name: Checkout repo (full)
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run weather updater (Batch ${{ matrix.batch }})
        run: |
          python weather_updater.py --once --batch-size 30 --batch-number ${{ matrix.batch }}
        env:
          GITHUB_ACTIONS: 'true'
          JAWG_TOKEN: ${{ secrets.JAWG_TOKEN }}

      - name: Show artifact file info
        run: |
          if [ -f weather_cache.json ]; then
            echo "weather_cache.json exists, size:"
            ls -l weather_cache.json
            echo "head (first 200 chars):"
            head -c 200 weather_cache.json || true
          else
            echo "weather_cache.json not produced by this batch."
          fi

      - name: Upload batch artifact
        uses: actions/upload-artifact@v4
        with:
          name: batch-${{ matrix.batch }}
          path: weather_cache.json
          retention-days: 1

  combine-and-commit:
    name: Combine artifacts, validate, compare, commit if changed
    needs: update-weather
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository (full)
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Fix remote URL (remove trailing dot if any)
        run: |
          orig=$(git remote get-url origin)
          echo "Original remote URL: $orig"
          fixed=$(echo "$orig" | sed 's/\.$//')
          git remote set-url origin "$fixed"
          echo "Fixed remote URL:"
          git remote -v

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Download all batch artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
          pattern: batch-*

      - name: Combine batch artifacts into weather_cache.json
        id: combine
        run: |
          python - <<'PY'
          import os, json, sys

          artifacts_root = "artifacts"
          combined = {}
          total_loaded = 0
          corrupted = 0

          if not os.path.isdir(artifacts_root):
              print("No artifacts directory found.")
              open("weather_cache.json","w").write("{}")
              sys.exit(0)

          for root, dirs, files in os.walk(artifacts_root):
              for fname in files:
                  if fname == "weather_cache.json":
                      path = os.path.join(root, fname)
                      try:
                          if os.path.getsize(path) == 0:
                              print(f"Skipping empty file: {path}")
                              continue
                          with open(path, 'r', encoding='utf-8') as f:
                              data = json.load(f)
                          if not isinstance(data, dict):
                              print(f"Skipping non-dict JSON from {path}")
                              corrupted += 1
                              continue
                          # merge (later batches override earlier keys)
                          combined.update(data)
                          total_loaded += len(data)
                          print(f"Loaded {len(data)} entries from {path}")
                      except Exception as e:
                          print(f"Error reading {path}: {e}")
                          corrupted += 1

          print(f"Combined total entries: {len(combined)} (loaded sum: {total_loaded}, corrupted files: {corrupted})")
          # Write combined file
          with open("weather_cache.json", "w", encoding="utf-8") as out:
              json.dump(combined, out, ensure_ascii=False, indent=2)
          # Emit metadata for workflow consumption
          print(f"::set-output name=entries::{len(combined)}")
          print(f"::set-output name=corrupted::{corrupted}")
          PY

      - name: Validate merged cache (structure & minimal sanity)
        id: validate
        run: |
          python - <<'PY'
          import json, sys, os, datetime

          def is_valid_entry(v):
              if not isinstance(v, dict):
                  return False
              if 'last_updated' not in v:
                  return False
              try:
                  # quick ISO timestamp parse
                  datetime.datetime.fromisoformat(v['last_updated'])
              except Exception:
                  return False
              return True

          merged_path = "weather_cache.json"
          if not os.path.exists(merged_path):
              print("Merged cache missing")
              print("::set-output name=valid::false")
              sys.exit(0)

          try:
              with open(merged_path, 'r', encoding='utf-8') as f:
                  merged = json.load(f)
          except Exception as e:
              print("Merged cache is not valid JSON:", e)
              print("::set-output name=valid::false")
              sys.exit(0)

          if not isinstance(merged, dict):
              print("Merged cache is not a dict")
              print("::set-output name=valid::false")
              sys.exit(0)

          # Minimal checks: not empty and at least some valid entries
          valid_count = 0
          total = 0
          for k, v in merged.items():
              total += 1
              if is_valid_entry(v):
                  valid_count += 1

          print(f"Merged total entries: {total}, valid entries with last_updated: {valid_count}")
          # Require at least 1 valid entry (you can tighten this threshold)
          ok = (total > 0 and valid_count >= 1)
          print(f"::set-output name=valid::{str(ok).lower()}")
          PY

      # Retrieve previous committed cache (from the checked-out repo)
      - name: Copy previous committed cache to workspace
        run: |
          if [ -f weather_cache.json ]; then
            cp weather_cache.json previous_cache.json || true
            echo "Previous committed cache copied to previous_cache.json"
            echo "Previous cache size:"
            ls -l previous_cache.json || true
          else
            echo "{}" > previous_cache.json
            echo "No previous cache in repo; created empty previous_cache.json"
          fi

      - name: Compare new merged cache vs previous
        id: compare
        run: |
          python - <<'PY'
          import json, sys, os

          def normalize(d):
              # Keep key ordering independent and trim last_updated precision for robust equality
              out = {}
              for k,v in d.items():
                  if isinstance(v, dict):
                      # keep only important keys, and normalize last_updated to second resolution
                      nv = dict(v)
                      if 'last_updated' in nv:
                          try:
                              from datetime import datetime
                              dt = datetime.fromisoformat(nv['last_updated'])
                              nv['last_updated'] = dt.replace(microsecond=0).isoformat()
                          except Exception:
                              nv['last_updated'] = nv.get('last_updated')
                      out[k] = nv
                  else:
                      out[k] = v
              return out

          with open("weather_cache.json","r",encoding="utf-8") as f:
              new = json.load(f)
          with open("previous_cache.json","r",encoding="utf-8") as f:
              prev = json.load(f)

          new_n = normalize(new)
          prev_n = normalize(prev)

          if new_n == prev_n:
              print("Caches are identical -> no update needed")
              print("::set-output name=changed::false")
              sys.exit(0)
          else:
              print("Caches differ -> will attempt update")
              print("::set-output name=changed::true")
              # report counts
              print(f"::set-output name=new_count::{len(new)}")
              print(f"::set-output name=prev_count::{len(prev)}")
          PY

      - name: Abort if merged cache invalid
        if: steps.validate.outputs.valid != 'true'
        run: |
          echo "Merged cache failed validation; aborting commit to preserve previous cache"
          echo "Merged file preserved at workspace/weather_cache.json for inspection"
          exit 0

      - name: Commit merged cache (only if changed)
        if: steps.compare.outputs.changed == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          # Ensure we have latest main to avoid fast-forward issues
          git fetch origin main:main || true
          git checkout main || true
          git pull --rebase origin main || true
          # Overwrite file in working tree with merged result (already present)
          git add weather_cache.json
          if git diff --staged --quiet; then
            echo "No staged changes to commit"
          else
            git commit -m "Update combined weather cache (automated) - $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          fi

      - name: Push merged cache (only if changed)
        if: steps.compare.outputs.changed == 'true'
        run: |
          # Push with retries and rebase to avoid race conditions
          for i in 1 2 3; do
            if git push origin main; then
              echo "Push succeeded on attempt $i"
              exit 0
            else
              echo "Push failed on attempt $i, pulling and retrying..."
              git pull --rebase origin main || true
            fi
          done
          echo "All push attempts failed"
          exit 1

      - name: Save merged cache snapshot (artifact) for debugging
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: merged-weather-cache
          path: weather_cache.json
          retention-days: 3

      - name: Post-update: keep previous cache if no change
        if: steps.compare.outputs.changed == 'false'
        run: |
          echo "No update performed because merged cache is identical to previous committed cache."
          echo "Nothing to push or save."

      - name: Final status
        run: |
          echo "Compare changed = ${{ steps.compare.outputs.changed }}"
          echo "Validate valid = ${{ steps.validate.outputs.valid }}"
          echo "Combined entries = ${{ steps.combine.outputs.entries }}"
